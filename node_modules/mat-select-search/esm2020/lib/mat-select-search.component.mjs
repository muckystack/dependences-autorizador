import { Component, ElementRef, EventEmitter, Inject, Input, Optional, Output, ViewChild, } from '@angular/core';
import { MatOption } from '@angular/material/core';
import { MatSelect } from '@angular/material/select';
import { Subscription } from 'rxjs';
import { Searcher } from './searcher.service';
import { filter } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "./searcher.service";
import * as i2 from "@angular/material/progress-spinner";
import * as i3 from "@angular/material/divider";
import * as i4 from "@angular/common";
import * as i5 from "@angular/material/select";
import * as i6 from "@angular/material/core";
const NON_ITEM_OPTIONS_COUNT = 2;
const INDEX_SELECT_ALL = 1;
export class MatSelectSearchComponent {
    constructor(matSelect, matOption, renderer, searcher) {
        this.matSelect = matSelect;
        this.matOption = matOption;
        this.renderer = renderer;
        this.searcher = searcher;
        // Send the array which is to be searched/filtered
        this.list = [];
        // Send the keys of the object properties that is to be searched/filtered
        this.searchProperties = [];
        // Make true if input should be cleared on opening
        this.clearSearchInput = false;
        // Make true if mat-select has multiple attribute with true value
        this.isMultiSelect = false;
        // Make true if there is a mat-option for selecting all values
        this.hasSelectAll = false;
        // Make true if it is needed to fix the search bar on top while scrolling.
        this.fixOnTop = false;
        // Custom the placeholder of search area
        this.searchPlaceHolder = 'Search';
        this.filtered = new EventEmitter();
        this.isLoading = false;
        this.filteredList = [];
        this.fullList = [];
        this.hasFilteredBefore = false;
        this.subscriptions = new Subscription();
        this.selectedOptions = [];
        this.clickListenerSelectAll = () => { };
    }
    ngOnChanges(changes) {
        if (changes.list && Array.isArray(changes.list.currentValue)) {
            this.fullList = this.list;
            this.searcher.initSearch(this.list, this.searchProperties);
            this.filtered.emit(this.fullList);
        }
    }
    ngAfterViewInit() {
        // If there is option to select all options then it should support multi select
        if (this.hasSelectAll)
            this.isMultiSelect = true;
        this.configMatOption();
        this.fullList = this.list;
        this.searcher.initSearch(this.list, this.searchProperties);
        this.subscriptions.add(this.matSelect.openedChange.subscribe(() => {
            const input = this.element.nativeElement;
            input.focus();
            if ((this.filteredList && this.filteredList.length === 0 && this.hasFilteredBefore) || this.clearSearchInput) {
                input.value = '';
                this.filtered.emit(this.fullList);
            }
        }));
        this.subscriptions
            .add(this.filtered.subscribe(() => (this.isLoading = false)));
        this.subscriptions.add(this.matSelect.stateChanges
            .pipe(filter(() => this.hasSelectAll))
            .subscribe(() => {
            const matOptions = this.matSelect.options.toArray();
            const selectAll = matOptions[INDEX_SELECT_ALL]._getHostElement();
            if (matOptions.length > NON_ITEM_OPTIONS_COUNT) {
                this.renderer.setStyle(selectAll, 'display', 'flex');
            }
            else {
                this.renderer.setStyle(selectAll, 'display', 'none');
            }
            const items = matOptions.slice(NON_ITEM_OPTIONS_COUNT);
            const isAllItemsSelected = items.every(item => item.selected);
            if (isAllItemsSelected && items.length > NON_ITEM_OPTIONS_COUNT) {
                this.selectNativeSelectAllCheckbox();
            }
            else {
                this.deselectNativeSelectAllCheckbox();
            }
        }));
        setTimeout(() => this.filtered.emit(this.fullList));
    }
    filterList(event) {
        const inputEvent = event;
        this.hasFilteredBefore = true;
        this.isLoading = true;
        this.filteredList = this.searcher.filterList(inputEvent);
        if (!this.filteredList) {
            this.isLoading = false;
            return;
        }
        const listWithoutConcatedValues = this.filteredList.map(item => {
            const itemCopy = { ...item };
            delete itemCopy['concatedValues'];
            return itemCopy;
        });
        this.filtered.emit(listWithoutConcatedValues);
    }
    stopCharPropagation(event) {
        const key = event.key;
        const isTextControlKey = key === ' ' || key === 'Home' || key === 'End' || (key >= 'a' && key <= 'z');
        if (isTextControlKey) {
            event.stopPropagation();
        }
    }
    configMatOption() {
        if (!this.matOption) {
            console.error('<lib-mat-select-search> must be placed inside a <mat-option> element');
            return;
        }
        this.matOption.disabled = true;
        const nativeMatOption = this.matOption._getHostElement();
        const checkBox = nativeMatOption.childNodes[0];
        this.renderer.removeChild(nativeMatOption, checkBox);
        if (this.isMultiSelect)
            this.configMultiSelect();
        if (this.hasSelectAll)
            this.enableSelectAll();
        if (this.fixOnTop)
            this.fixSearchBarOnTopWhileScroll();
    }
    /*
      This method is used to retain the old selected options after selecting an option from the new filtered list.
      The old selected options are stored in selectedOptions and the new matSelect value is appended with selected options.
    */
    configMultiSelect() {
        this.subscriptions.add(this.matSelect.optionSelectionChanges.subscribe(change => {
            const isSelectAllOption = this.hasSelectAll && change.source.id === 'mat-option-1';
            if (!change.isUserInput || isSelectAllOption)
                return;
            const itemIndex = this.selectedOptions.indexOf(change.source.value);
            if (itemIndex > -1) {
                this.selectedOptions.splice(itemIndex, 1);
            }
            else {
                this.selectedOptions.push(change.source.value);
            }
            this.matSelect.value = [...this.selectedOptions];
            if (!this.hasSelectAll)
                return;
            const selectedOptionsCount = this.matSelect.options.filter(option => option.selected).length;
            const isAllOptionsSelected = selectedOptionsCount === this.matSelect.options.length - NON_ITEM_OPTIONS_COUNT;
            if (isAllOptionsSelected) {
                this.selectNativeSelectAllCheckbox();
                return;
            }
            if (this.nativeSelectAllCheckbox.getAttribute('checked')) {
                this.deselectNativeSelectAllCheckbox();
            }
        }));
    }
    /*
      This method helps the user to select all the options in a list. It must also be able to retain the old selected options
      after clicking Select All in new filtered list. But this has a problem.
      The checkbox before every mat-option is the default checkbox given by angular on a mat-option.
      This checkbox can only be checked manually by a method option.select().
      But this method not only checks the chekbox but also updates the value of the matSelect and hence after clicking on it,
      the matSelect value loses the old selected options and will only have all the options in the new filtered list.
  
      To overcome this we remove the default checkbox and create a new checkbox of our own. The newly created checkbox has also
      a slightly different appearance and hence contrasts with the rest of the checkboxes in the options so which is good as the
      user will get a feel that this particular option(Select All) is different from the rest of the options
    */
    enableSelectAll() {
        const selectAll = this.matSelect.options.toArray()[INDEX_SELECT_ALL];
        const nativeSelectAll = selectAll._getHostElement();
        const matPseudoCheckbox = nativeSelectAll.childNodes[0];
        this.renderer.removeChild(nativeSelectAll, matPseudoCheckbox);
        this.nativeSelectAllCheckbox = this.renderer.createElement('input');
        this.renderer.setAttribute(this.nativeSelectAllCheckbox, 'type', 'checkbox');
        this.renderer.addClass(this.nativeSelectAllCheckbox, 'native-checkbox');
        this.renderer.insertBefore(nativeSelectAll, this.nativeSelectAllCheckbox, nativeSelectAll.childNodes[0]);
        this.clickListenerSelectAll = this.renderer.listen(nativeSelectAll, 'click', () => {
            if (this.nativeSelectAllCheckbox.getAttribute('checked')) {
                this.deselectNativeSelectAllCheckbox();
                this.deselectAlloptions();
            }
            else {
                this.selectNativeSelectAllCheckbox();
                this.selectAllOptions();
            }
        });
    }
    selectAllOptions() {
        const matOptions = this.matSelect.options;
        const items = matOptions.toArray().slice(NON_ITEM_OPTIONS_COUNT);
        let nonSelectedItems = [];
        items.forEach(item => {
            if (!item.selected)
                nonSelectedItems.push(item.value);
        });
        this.selectedOptions = [...this.selectedOptions, ...nonSelectedItems];
        this.matSelect.value = [...this.selectedOptions];
    }
    deselectAlloptions() {
        const matOptions = this.matSelect.options;
        const items = matOptions.toArray().slice(NON_ITEM_OPTIONS_COUNT);
        const itemValues = items.map(item => item.value);
        this.matSelect.value = this.selectedOptions = this.selectedOptions.filter(option => !itemValues.includes(option));
    }
    fixSearchBarOnTopWhileScroll() {
        const searchBar = this.matSelect.options.toArray()[0]._getHostElement();
        this.renderer.setStyle(searchBar, 'position', 'sticky');
        this.renderer.setStyle(searchBar, 'top', '0');
        this.renderer.setStyle(searchBar, 'z-index', '1');
        this.renderer.setStyle(searchBar, 'background-color', 'white');
    }
    selectNativeSelectAllCheckbox() {
        this.renderer.setAttribute(this.nativeSelectAllCheckbox, 'checked', 'true');
    }
    deselectNativeSelectAllCheckbox() {
        this.renderer.removeAttribute(this.nativeSelectAllCheckbox, 'checked');
    }
    ngOnDestroy() {
        this.subscriptions.unsubscribe();
        this.clickListenerSelectAll();
    }
}
MatSelectSearchComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.5", ngImport: i0, type: MatSelectSearchComponent, deps: [{ token: MatSelect }, { token: MatOption, optional: true }, { token: i0.Renderer2 }, { token: i1.Searcher }], target: i0.ɵɵFactoryTarget.Component });
MatSelectSearchComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "14.0.5", type: MatSelectSearchComponent, selector: "lib-mat-select-search", inputs: { list: "list", searchProperties: "searchProperties", clearSearchInput: "clearSearchInput", isMultiSelect: "isMultiSelect", hasSelectAll: "hasSelectAll", fixOnTop: "fixOnTop", searchPlaceHolder: "searchPlaceHolder" }, outputs: { filtered: "filtered" }, providers: [Searcher], viewQueries: [{ propertyName: "element", first: true, predicate: ["input"], descendants: true, read: ElementRef, static: true }], usesOnChanges: true, ngImport: i0, template: "<div class=\"flex-container\">\n  <input\n    #input\n    id=\"input\"\n    [placeholder]=\"searchPlaceHolder\"\n    autocomplete=\"off\"\n    (input)=\"filterList($event)\"\n    (keydown)=\"stopCharPropagation($event)\">\n    <mat-spinner *ngIf=\"isLoading\" [diameter]=\"25\"></mat-spinner>\n</div>\n<mat-divider></mat-divider>\n", styles: [".flex-container{display:flex;align-items:center;justify-content:space-between;height:100%}input{border:none;width:calc(100% - 25px);outline:none;margin-top:2%;margin-bottom:2%;height:100%}\n"], dependencies: [{ kind: "component", type: i2.MatProgressSpinner, selector: "mat-progress-spinner, mat-spinner", inputs: ["color", "diameter", "strokeWidth", "mode", "value"], exportAs: ["matProgressSpinner"] }, { kind: "component", type: i3.MatDivider, selector: "mat-divider", inputs: ["vertical", "inset"] }, { kind: "directive", type: i4.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.5", ngImport: i0, type: MatSelectSearchComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-mat-select-search', providers: [Searcher], template: "<div class=\"flex-container\">\n  <input\n    #input\n    id=\"input\"\n    [placeholder]=\"searchPlaceHolder\"\n    autocomplete=\"off\"\n    (input)=\"filterList($event)\"\n    (keydown)=\"stopCharPropagation($event)\">\n    <mat-spinner *ngIf=\"isLoading\" [diameter]=\"25\"></mat-spinner>\n</div>\n<mat-divider></mat-divider>\n", styles: [".flex-container{display:flex;align-items:center;justify-content:space-between;height:100%}input{border:none;width:calc(100% - 25px);outline:none;margin-top:2%;margin-bottom:2%;height:100%}\n"] }]
        }], ctorParameters: function () { return [{ type: i5.MatSelect, decorators: [{
                    type: Inject,
                    args: [MatSelect]
                }] }, { type: i6.MatOption, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [MatOption]
                }] }, { type: i0.Renderer2 }, { type: i1.Searcher }]; }, propDecorators: { list: [{
                type: Input
            }], searchProperties: [{
                type: Input
            }], clearSearchInput: [{
                type: Input
            }], isMultiSelect: [{
                type: Input
            }], hasSelectAll: [{
                type: Input
            }], fixOnTop: [{
                type: Input
            }], searchPlaceHolder: [{
                type: Input
            }], filtered: [{
                type: Output
            }], element: [{
                type: ViewChild,
                args: ['input', { read: ElementRef, static: true }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0LXNlbGVjdC1zZWFyY2guY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vcHJvamVjdHMvbWF0LXNlbGVjdC1zZWFyY2gvc3JjL2xpYi9tYXQtc2VsZWN0LXNlYXJjaC5jb21wb25lbnQudHMiLCIuLi8uLi8uLi8uLi9wcm9qZWN0cy9tYXQtc2VsZWN0LXNlYXJjaC9zcmMvbGliL21hdC1zZWxlY3Qtc2VhcmNoLmNvbXBvbmVudC5odG1sIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFHTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sS0FBSyxFQUVMLFFBQVEsRUFFUixNQUFNLEVBRU4sU0FBUyxHQUVWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNuRCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDckQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwQyxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDOUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7Ozs7OztBQUV4QyxNQUFNLHNCQUFzQixHQUFHLENBQUMsQ0FBQztBQUNqQyxNQUFNLGdCQUFnQixHQUFHLENBQUMsQ0FBQztBQVMzQixNQUFNLE9BQU8sd0JBQXdCO0lBbUNuQyxZQUM2QixTQUFvQixFQUNSLFNBQW9CLEVBQ25ELFFBQW1CLEVBQ25CLFFBQWtCO1FBSEMsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNSLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDbkQsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUNuQixhQUFRLEdBQVIsUUFBUSxDQUFVO1FBcEM1QixrREFBa0Q7UUFDekMsU0FBSSxHQUE2QixFQUFFLENBQUM7UUFFN0MseUVBQXlFO1FBQ2hF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QUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsdUJBQXVCLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDekUsQ0FBQztJQUVELFdBQVc7UUFDVCxJQUFJLENBQUMsYUFBYSxDQUFDLFdBQVcsRUFBRSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxzQkFBc0IsRUFBRSxDQUFDO0lBQ2hDLENBQUM7O3FIQTlPVSx3QkFBd0Isa0JBb0N6QixTQUFTLGFBQ0csU0FBUzt5R0FyQ3BCLHdCQUF3QixxVEFGeEIsQ0FBQyxRQUFRLENBQUMsdUdBMkJPLFVBQVUsZ0VDekR4Qyw2VUFXQTsyRkRxQmEsd0JBQXdCO2tCQVBwQyxTQUFTOytCQUNFLHVCQUF1QixhQUl0QixDQUFDLFFBQVEsQ0FBQzs7MEJBc0NsQixNQUFNOzJCQUFDLFNBQVM7OzBCQUNoQixRQUFROzswQkFBSSxNQUFNOzJCQUFDLFNBQVM7MkZBakN0QixJQUFJO3NCQUFaLEtBQUs7Z0JBR0csZ0JBQWdCO3NCQUF4QixLQUFLO2dCQUdHLGdCQUFnQjtzQkFBeEIsS0FBSztnQkFHRyxhQUFhO3NCQUFyQixLQUFLO2dCQUdHLFlBQVk7c0JBQXBCLEtBQUs7Z0JBR0csUUFBUTtzQkFBaEIsS0FBSztnQkFHRyxpQkFBaUI7c0JBQXpCLEtBQUs7Z0JBRUksUUFBUTtzQkFBakIsTUFBTTtnQkFDaUQsT0FBTztzQkFBOUQsU0FBUzt1QkFBQyxPQUFPLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBBZnRlclZpZXdJbml0LFxuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEluamVjdCxcbiAgSW5wdXQsXG4gIE9uRGVzdHJveSxcbiAgT3B0aW9uYWwsXG4gIE9uQ2hhbmdlcyxcbiAgT3V0cHV0LFxuICBSZW5kZXJlcjIsXG4gIFZpZXdDaGlsZCxcbiAgU2ltcGxlQ2hhbmdlcyxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXRPcHRpb24gfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IE1hdFNlbGVjdCB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL3NlbGVjdCc7XG5pbXBvcnQgeyBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFNlYXJjaGVyIH0gZnJvbSAnLi9zZWFyY2hlci5zZXJ2aWNlJztcbmltcG9ydCB7IGZpbHRlciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuY29uc3QgTk9OX0lURU1fT1BUSU9OU19DT1VOVCA9IDI7XG5jb25zdCBJTkRFWF9TRUxFQ1RfQUxMID0gMTtcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbGliLW1hdC1zZWxlY3Qtc2VhcmNoJyxcbiAgdGVtcGxhdGVVcmw6ICcuL21hdC1zZWxlY3Qtc2VhcmNoLmNvbXBvbmVudC5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJy4vbWF0LXNlbGVjdC1zZWFyY2guc2NzcyddLFxuICAvL2NoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICBwcm92aWRlcnM6IFtTZWFyY2hlcl0sXG59KVxuZXhwb3J0IGNsYXNzIE1hdFNlbGVjdFNlYXJjaENvbXBvbmVudFxuICBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzXG57XG4gIC8vIFNlbmQgdGhlIGFycmF5IHdoaWNoIGlzIHRvIGJlIHNlYXJjaGVkL2ZpbHRlcmVkXG4gIEBJbnB1dCgpIGxpc3Q6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXSA9IFtdO1xuXG4gIC8vIFNlbmQgdGhlIGtleXMgb2YgdGhlIG9iamVjdCBwcm9wZXJ0aWVzIHRoYXQgaXMgdG8gYmUgc2VhcmNoZWQvZmlsdGVyZWRcbiAgQElucHV0KCkgc2VhcmNoUHJvcGVydGllczogc3RyaW5nW10gPSBbXTtcblxuICAvLyBNYWtlIHRydWUgaWYgaW5wdXQgc2hvdWxkIGJlIGNsZWFyZWQgb24gb3BlbmluZ1xuICBASW5wdXQoKSBjbGVhclNlYXJjaElucHV0ID0gZmFsc2U7XG5cbiAgLy8gTWFrZSB0cnVlIGlmIG1hdC1zZWxlY3QgaGFzIG11bHRpcGxlIGF0dHJpYnV0ZSB3aXRoIHRydWUgdmFsdWVcbiAgQElucHV0KCkgaXNNdWx0aVNlbGVjdCA9IGZhbHNlO1xuXG4gIC8vIE1ha2UgdHJ1ZSBpZiB0aGVyZSBpcyBhIG1hdC1vcHRpb24gZm9yIHNlbGVjdGluZyBhbGwgdmFsdWVzXG4gIEBJbnB1dCgpIGhhc1NlbGVjdEFsbCA9IGZhbHNlO1xuXG4gIC8vIE1ha2UgdHJ1ZSBpZiBpdCBpcyBuZWVkZWQgdG8gZml4IHRoZSBzZWFyY2ggYmFyIG9uIHRvcCB3aGlsZSBzY3JvbGxpbmcuXG4gIEBJbnB1dCgpIGZpeE9uVG9wID0gZmFsc2U7XG5cbiAgLy8gQ3VzdG9tIHRoZSBwbGFjZWhvbGRlciBvZiBzZWFyY2ggYXJlYVxuICBASW5wdXQoKSBzZWFyY2hQbGFjZUhvbGRlcjogc3RyaW5nID0gJ1NlYXJjaCc7XG5cbiAgQE91dHB1dCgpIGZpbHRlcmVkID0gbmV3IEV2ZW50RW1pdHRlcjxSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+W10+KCk7XG4gIEBWaWV3Q2hpbGQoJ2lucHV0JywgeyByZWFkOiBFbGVtZW50UmVmLCBzdGF0aWM6IHRydWUgfSkgZWxlbWVudCE6IEVsZW1lbnRSZWY7XG4gIGlzTG9hZGluZyA9IGZhbHNlO1xuICBwcml2YXRlIGZpbHRlcmVkTGlzdDogUmVjb3JkPHN0cmluZywgc3RyaW5nPltdIHwgdW5kZWZpbmVkID0gW107XG4gIHByaXZhdGUgZnVsbExpc3Q6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXSA9IFtdO1xuICBwcml2YXRlIGhhc0ZpbHRlcmVkQmVmb3JlID0gZmFsc2U7XG4gIHByaXZhdGUgc3Vic2NyaXB0aW9ucyA9IG5ldyBTdWJzY3JpcHRpb24oKTtcbiAgcHJpdmF0ZSBzZWxlY3RlZE9wdGlvbnM6IGFueVtdID0gW107XG4gIHByaXZhdGUgbmF0aXZlU2VsZWN0QWxsQ2hlY2tib3ghOiBIVE1MRWxlbWVudDtcbiAgcHJpdmF0ZSBjbGlja0xpc3RlbmVyU2VsZWN0QWxsID0gKCkgPT4ge307XG5cbiAgY29uc3RydWN0b3IoXG4gICAgQEluamVjdChNYXRTZWxlY3QpIHByaXZhdGUgbWF0U2VsZWN0OiBNYXRTZWxlY3QsXG4gICAgQE9wdGlvbmFsKCkgQEluamVjdChNYXRPcHRpb24pIHByaXZhdGUgbWF0T3B0aW9uOiBNYXRPcHRpb24sXG4gICAgcHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgc2VhcmNoZXI6IFNlYXJjaGVyXG4gICkge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKGNoYW5nZXMubGlzdCAmJiBBcnJheS5pc0FycmF5KGNoYW5nZXMubGlzdC5jdXJyZW50VmFsdWUpKSB7XG4gICAgICB0aGlzLmZ1bGxMaXN0ID0gdGhpcy5saXN0O1xuICAgICAgdGhpcy5zZWFyY2hlci5pbml0U2VhcmNoKHRoaXMubGlzdCwgdGhpcy5zZWFyY2hQcm9wZXJ0aWVzKTtcbiAgICAgIHRoaXMuZmlsdGVyZWQuZW1pdCh0aGlzLmZ1bGxMaXN0KTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XG4gICAgLy8gSWYgdGhlcmUgaXMgb3B0aW9uIHRvIHNlbGVjdCBhbGwgb3B0aW9ucyB0aGVuIGl0IHNob3VsZCBzdXBwb3J0IG11bHRpIHNlbGVjdFxuICAgIGlmICh0aGlzLmhhc1NlbGVjdEFsbCkgdGhpcy5pc011bHRpU2VsZWN0ID0gdHJ1ZTtcbiAgICB0aGlzLmNvbmZpZ01hdE9wdGlvbigpO1xuICAgIHRoaXMuZnVsbExpc3QgPSB0aGlzLmxpc3Q7XG4gICAgdGhpcy5zZWFyY2hlci5pbml0U2VhcmNoKHRoaXMubGlzdCwgdGhpcy5zZWFyY2hQcm9wZXJ0aWVzKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5tYXRTZWxlY3Qub3BlbmVkQ2hhbmdlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICBpbnB1dC5mb2N1cygpO1xuICAgICAgICAgIGlmICgodGhpcy5maWx0ZXJlZExpc3QgJiYgdGhpcy5maWx0ZXJlZExpc3QubGVuZ3RoID09PSAwICYmIHRoaXMuaGFzRmlsdGVyZWRCZWZvcmUpIHx8IHRoaXMuY2xlYXJTZWFyY2hJbnB1dCkge1xuICAgICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICB0aGlzLmZpbHRlcmVkLmVtaXQodGhpcy5mdWxsTGlzdCk7XG4gICAgICAgICAgfVxuICAgICAgfSkpO1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zXG4gICAgICAgICAgLmFkZCh0aGlzLmZpbHRlcmVkLnN1YnNjcmliZSgoKSA9PiAodGhpcy5pc0xvYWRpbmcgPSBmYWxzZSkpKTtcbiAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQoXG4gICAgICAgIHRoaXMubWF0U2VsZWN0LnN0YXRlQ2hhbmdlc1xuICAgICAgICAgIC5waXBlKGZpbHRlcigoKSA9PiB0aGlzLmhhc1NlbGVjdEFsbCkpXG4gICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtYXRPcHRpb25zID0gdGhpcy5tYXRTZWxlY3Qub3B0aW9ucy50b0FycmF5KCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RBbGwgPSBtYXRPcHRpb25zW0lOREVYX1NFTEVDVF9BTExdLl9nZXRIb3N0RWxlbWVudCgpO1xuICAgICAgICAgICAgaWYgKG1hdE9wdGlvbnMubGVuZ3RoID4gTk9OX0lURU1fT1BUSU9OU19DT1VOVCkge1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHNlbGVjdEFsbCwgJ2Rpc3BsYXknLCAnZmxleCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShzZWxlY3RBbGwsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBtYXRPcHRpb25zLnNsaWNlKE5PTl9JVEVNX09QVElPTlNfQ09VTlQpO1xuICAgICAgICAgICAgY29uc3QgaXNBbGxJdGVtc1NlbGVjdGVkID0gaXRlbXMuZXZlcnkoaXRlbSA9PiBpdGVtLnNlbGVjdGVkKTtcbiAgICAgICAgICAgIGlmIChpc0FsbEl0ZW1zU2VsZWN0ZWQgJiYgaXRlbXMubGVuZ3RoID4gTk9OX0lURU1fT1BUSU9OU19DT1VOVCkge1xuICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5hdGl2ZVNlbGVjdEFsbENoZWNrYm94KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0TmF0aXZlU2VsZWN0QWxsQ2hlY2tib3goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgKTtcblxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5maWx0ZXJlZC5lbWl0KHRoaXMuZnVsbExpc3QpKTtcbiAgfVxuXG4gIGZpbHRlckxpc3QoZXZlbnQ6IEV2ZW50KTogdm9pZCB7XG4gICAgY29uc3QgaW5wdXRFdmVudCA9IGV2ZW50IGFzIElucHV0RXZlbnQ7XG4gICAgdGhpcy5oYXNGaWx0ZXJlZEJlZm9yZSA9IHRydWU7XG4gICAgdGhpcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgIHRoaXMuZmlsdGVyZWRMaXN0ID0gdGhpcy5zZWFyY2hlci5maWx0ZXJMaXN0KGlucHV0RXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLmZpbHRlcmVkTGlzdCkge1xuICAgICAgdGhpcy5pc0xvYWRpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBsaXN0V2l0aG91dENvbmNhdGVkVmFsdWVzID0gdGhpcy5maWx0ZXJlZExpc3QubWFwKGl0ZW0gPT4ge1xuICAgICAgY29uc3QgaXRlbUNvcHkgPSB7Li4uaXRlbX07XG4gICAgICBkZWxldGUgaXRlbUNvcHlbJ2NvbmNhdGVkVmFsdWVzJ107XG4gICAgICByZXR1cm4gaXRlbUNvcHk7XG4gICAgfSk7XG4gICAgdGhpcy5maWx0ZXJlZC5lbWl0KGxpc3RXaXRob3V0Q29uY2F0ZWRWYWx1ZXMpO1xuICB9XG5cbiAgc3RvcENoYXJQcm9wYWdhdGlvbihldmVudDogS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIGNvbnN0IGtleSA9IGV2ZW50LmtleTtcbiAgICBjb25zdCBpc1RleHRDb250cm9sS2V5ID0ga2V5ID09PSAnICcgfHwga2V5ID09PSAnSG9tZScgfHwga2V5ID09PSAnRW5kJyB8fCAoa2V5ID49ICdhJyAmJiBrZXkgPD0gJ3onKTtcbiAgICBpZiAoaXNUZXh0Q29udHJvbEtleSkgeyBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgfVxuICB9XG5cbiAgcHJpdmF0ZSBjb25maWdNYXRPcHRpb24oKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLm1hdE9wdGlvbikge1xuICAgICAgY29uc29sZS5lcnJvcignPGxpYi1tYXQtc2VsZWN0LXNlYXJjaD4gbXVzdCBiZSBwbGFjZWQgaW5zaWRlIGEgPG1hdC1vcHRpb24+IGVsZW1lbnQnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5tYXRPcHRpb24uZGlzYWJsZWQgPSB0cnVlO1xuICAgIGNvbnN0IG5hdGl2ZU1hdE9wdGlvbiA9IHRoaXMubWF0T3B0aW9uLl9nZXRIb3N0RWxlbWVudCgpO1xuICAgIGNvbnN0IGNoZWNrQm94ID0gbmF0aXZlTWF0T3B0aW9uLmNoaWxkTm9kZXNbMF07XG4gICAgdGhpcy5yZW5kZXJlci5yZW1vdmVDaGlsZChuYXRpdmVNYXRPcHRpb24sIGNoZWNrQm94KTtcblxuICAgIGlmICh0aGlzLmlzTXVsdGlTZWxlY3QpIHRoaXMuY29uZmlnTXVsdGlTZWxlY3QoKTtcbiAgICBpZiAodGhpcy5oYXNTZWxlY3RBbGwpIHRoaXMuZW5hYmxlU2VsZWN0QWxsKCk7XG4gICAgaWYgKHRoaXMuZml4T25Ub3ApIHRoaXMuZml4U2VhcmNoQmFyT25Ub3BXaGlsZVNjcm9sbCgpO1xuICB9XG5cblxuICAvKlxuICAgIFRoaXMgbWV0aG9kIGlzIHVzZWQgdG8gcmV0YWluIHRoZSBvbGQgc2VsZWN0ZWQgb3B0aW9ucyBhZnRlciBzZWxlY3RpbmcgYW4gb3B0aW9uIGZyb20gdGhlIG5ldyBmaWx0ZXJlZCBsaXN0LlxuICAgIFRoZSBvbGQgc2VsZWN0ZWQgb3B0aW9ucyBhcmUgc3RvcmVkIGluIHNlbGVjdGVkT3B0aW9ucyBhbmQgdGhlIG5ldyBtYXRTZWxlY3QgdmFsdWUgaXMgYXBwZW5kZWQgd2l0aCBzZWxlY3RlZCBvcHRpb25zLlxuICAqL1xuICBwcml2YXRlIGNvbmZpZ011bHRpU2VsZWN0KCk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5tYXRTZWxlY3Qub3B0aW9uU2VsZWN0aW9uQ2hhbmdlcy5zdWJzY3JpYmUoY2hhbmdlID0+IHtcbiAgICAgIGNvbnN0IGlzU2VsZWN0QWxsT3B0aW9uID0gdGhpcy5oYXNTZWxlY3RBbGwgJiYgY2hhbmdlLnNvdXJjZS5pZCA9PT0gJ21hdC1vcHRpb24tMSc7XG4gICAgICBpZiAoIWNoYW5nZS5pc1VzZXJJbnB1dCB8fCBpc1NlbGVjdEFsbE9wdGlvbikgcmV0dXJuO1xuICAgICAgY29uc3QgaXRlbUluZGV4ID0gdGhpcy5zZWxlY3RlZE9wdGlvbnMuaW5kZXhPZihjaGFuZ2Uuc291cmNlLnZhbHVlKTtcbiAgICAgIGlmIChpdGVtSW5kZXggPiAtMSkge1xuICAgICAgICB0aGlzLnNlbGVjdGVkT3B0aW9ucy5zcGxpY2UoaXRlbUluZGV4LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25zLnB1c2goY2hhbmdlLnNvdXJjZS52YWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLm1hdFNlbGVjdC52YWx1ZSA9IFsuLi50aGlzLnNlbGVjdGVkT3B0aW9uc107XG5cbiAgICAgIGlmICghdGhpcy5oYXNTZWxlY3RBbGwpIHJldHVybjtcbiAgICAgIGNvbnN0IHNlbGVjdGVkT3B0aW9uc0NvdW50ID0gdGhpcy5tYXRTZWxlY3Qub3B0aW9ucy5maWx0ZXIob3B0aW9uID0+IG9wdGlvbi5zZWxlY3RlZCkubGVuZ3RoO1xuICAgICAgY29uc3QgaXNBbGxPcHRpb25zU2VsZWN0ZWQgPVxuICAgICAgICBzZWxlY3RlZE9wdGlvbnNDb3VudCA9PT0gdGhpcy5tYXRTZWxlY3Qub3B0aW9ucy5sZW5ndGggLSBOT05fSVRFTV9PUFRJT05TX0NPVU5UO1xuICAgICAgaWYgKGlzQWxsT3B0aW9uc1NlbGVjdGVkKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0TmF0aXZlU2VsZWN0QWxsQ2hlY2tib3goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5uYXRpdmVTZWxlY3RBbGxDaGVja2JveC5nZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgICB0aGlzLmRlc2VsZWN0TmF0aXZlU2VsZWN0QWxsQ2hlY2tib3goKTtcbiAgICAgIH1cbiAgICB9KSk7XG4gIH1cblxuICAvKlxuICAgIFRoaXMgbWV0aG9kIGhlbHBzIHRoZSB1c2VyIHRvIHNlbGVjdCBhbGwgdGhlIG9wdGlvbnMgaW4gYSBsaXN0LiBJdCBtdXN0IGFsc28gYmUgYWJsZSB0byByZXRhaW4gdGhlIG9sZCBzZWxlY3RlZCBvcHRpb25zXG4gICAgYWZ0ZXIgY2xpY2tpbmcgU2VsZWN0IEFsbCBpbiBuZXcgZmlsdGVyZWQgbGlzdC4gQnV0IHRoaXMgaGFzIGEgcHJvYmxlbS5cbiAgICBUaGUgY2hlY2tib3ggYmVmb3JlIGV2ZXJ5IG1hdC1vcHRpb24gaXMgdGhlIGRlZmF1bHQgY2hlY2tib3ggZ2l2ZW4gYnkgYW5ndWxhciBvbiBhIG1hdC1vcHRpb24uXG4gICAgVGhpcyBjaGVja2JveCBjYW4gb25seSBiZSBjaGVja2VkIG1hbnVhbGx5IGJ5IGEgbWV0aG9kIG9wdGlvbi5zZWxlY3QoKS5cbiAgICBCdXQgdGhpcyBtZXRob2Qgbm90IG9ubHkgY2hlY2tzIHRoZSBjaGVrYm94IGJ1dCBhbHNvIHVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBtYXRTZWxlY3QgYW5kIGhlbmNlIGFmdGVyIGNsaWNraW5nIG9uIGl0LFxuICAgIHRoZSBtYXRTZWxlY3QgdmFsdWUgbG9zZXMgdGhlIG9sZCBzZWxlY3RlZCBvcHRpb25zIGFuZCB3aWxsIG9ubHkgaGF2ZSBhbGwgdGhlIG9wdGlvbnMgaW4gdGhlIG5ldyBmaWx0ZXJlZCBsaXN0LlxuXG4gICAgVG8gb3ZlcmNvbWUgdGhpcyB3ZSByZW1vdmUgdGhlIGRlZmF1bHQgY2hlY2tib3ggYW5kIGNyZWF0ZSBhIG5ldyBjaGVja2JveCBvZiBvdXIgb3duLiBUaGUgbmV3bHkgY3JlYXRlZCBjaGVja2JveCBoYXMgYWxzb1xuICAgIGEgc2xpZ2h0bHkgZGlmZmVyZW50IGFwcGVhcmFuY2UgYW5kIGhlbmNlIGNvbnRyYXN0cyB3aXRoIHRoZSByZXN0IG9mIHRoZSBjaGVja2JveGVzIGluIHRoZSBvcHRpb25zIHNvIHdoaWNoIGlzIGdvb2QgYXMgdGhlXG4gICAgdXNlciB3aWxsIGdldCBhIGZlZWwgdGhhdCB0aGlzIHBhcnRpY3VsYXIgb3B0aW9uKFNlbGVjdCBBbGwpIGlzIGRpZmZlcmVudCBmcm9tIHRoZSByZXN0IG9mIHRoZSBvcHRpb25zXG4gICovXG4gIHByaXZhdGUgZW5hYmxlU2VsZWN0QWxsKCk6IHZvaWQge1xuICAgIGNvbnN0IHNlbGVjdEFsbCA9IHRoaXMubWF0U2VsZWN0Lm9wdGlvbnMudG9BcnJheSgpW0lOREVYX1NFTEVDVF9BTExdO1xuICAgIGNvbnN0IG5hdGl2ZVNlbGVjdEFsbCA9IHNlbGVjdEFsbC5fZ2V0SG9zdEVsZW1lbnQoKTtcbiAgICBjb25zdCBtYXRQc2V1ZG9DaGVja2JveCA9IG5hdGl2ZVNlbGVjdEFsbC5jaGlsZE5vZGVzWzBdO1xuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQ2hpbGQobmF0aXZlU2VsZWN0QWxsLCBtYXRQc2V1ZG9DaGVja2JveCk7XG5cbiAgICB0aGlzLm5hdGl2ZVNlbGVjdEFsbENoZWNrYm94ID0gdGhpcy5yZW5kZXJlci5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHRoaXMucmVuZGVyZXIuc2V0QXR0cmlidXRlKHRoaXMubmF0aXZlU2VsZWN0QWxsQ2hlY2tib3gsICd0eXBlJywgJ2NoZWNrYm94Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLm5hdGl2ZVNlbGVjdEFsbENoZWNrYm94LCAnbmF0aXZlLWNoZWNrYm94Jyk7XG4gICAgdGhpcy5yZW5kZXJlci5pbnNlcnRCZWZvcmUobmF0aXZlU2VsZWN0QWxsLCB0aGlzLm5hdGl2ZVNlbGVjdEFsbENoZWNrYm94LCBuYXRpdmVTZWxlY3RBbGwuY2hpbGROb2Rlc1swXSk7XG5cbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJTZWxlY3RBbGwgPSB0aGlzLnJlbmRlcmVyLmxpc3RlbihuYXRpdmVTZWxlY3RBbGwsICdjbGljaycsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLm5hdGl2ZVNlbGVjdEFsbENoZWNrYm94LmdldEF0dHJpYnV0ZSgnY2hlY2tlZCcpKSB7XG4gICAgICAgIHRoaXMuZGVzZWxlY3ROYXRpdmVTZWxlY3RBbGxDaGVja2JveCgpO1xuICAgICAgICB0aGlzLmRlc2VsZWN0QWxsb3B0aW9ucygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZWxlY3ROYXRpdmVTZWxlY3RBbGxDaGVja2JveCgpO1xuICAgICAgICB0aGlzLnNlbGVjdEFsbE9wdGlvbnMoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgc2VsZWN0QWxsT3B0aW9ucygpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRPcHRpb25zID0gdGhpcy5tYXRTZWxlY3Qub3B0aW9ucztcbiAgICBjb25zdCBpdGVtcyA9IG1hdE9wdGlvbnMudG9BcnJheSgpLnNsaWNlKE5PTl9JVEVNX09QVElPTlNfQ09VTlQpO1xuXG4gICAgbGV0IG5vblNlbGVjdGVkSXRlbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5bXSA9IFtdO1xuICAgIGl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uc2VsZWN0ZWQpIG5vblNlbGVjdGVkSXRlbXMucHVzaChpdGVtLnZhbHVlKTtcbiAgICB9KTtcblxuICAgIHRoaXMuc2VsZWN0ZWRPcHRpb25zID0gWy4uLnRoaXMuc2VsZWN0ZWRPcHRpb25zLCAuLi5ub25TZWxlY3RlZEl0ZW1zXTtcbiAgICB0aGlzLm1hdFNlbGVjdC52YWx1ZSA9IFsuLi50aGlzLnNlbGVjdGVkT3B0aW9uc107XG4gIH1cblxuICBwcml2YXRlIGRlc2VsZWN0QWxsb3B0aW9ucygpOiB2b2lkIHtcbiAgICBjb25zdCBtYXRPcHRpb25zID0gdGhpcy5tYXRTZWxlY3Qub3B0aW9ucztcbiAgICBjb25zdCBpdGVtcyA9IG1hdE9wdGlvbnMudG9BcnJheSgpLnNsaWNlKE5PTl9JVEVNX09QVElPTlNfQ09VTlQpO1xuICAgIGNvbnN0IGl0ZW1WYWx1ZXMgPSBpdGVtcy5tYXAoaXRlbSA9PiBpdGVtLnZhbHVlKVxuICAgIHRoaXMubWF0U2VsZWN0LnZhbHVlID0gdGhpcy5zZWxlY3RlZE9wdGlvbnMgPSB0aGlzLnNlbGVjdGVkT3B0aW9ucy5maWx0ZXIoXG4gICAgICBvcHRpb24gPT4gIWl0ZW1WYWx1ZXMuaW5jbHVkZXMob3B0aW9uKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIGZpeFNlYXJjaEJhck9uVG9wV2hpbGVTY3JvbGwoKTogdm9pZCB7XG4gICAgY29uc3Qgc2VhcmNoQmFyID0gdGhpcy5tYXRTZWxlY3Qub3B0aW9ucy50b0FycmF5KClbMF0uX2dldEhvc3RFbGVtZW50KCk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShzZWFyY2hCYXIsICdwb3NpdGlvbicsICdzdGlja3knKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHNlYXJjaEJhciwgJ3RvcCcsICcwJyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZShzZWFyY2hCYXIsICd6LWluZGV4JywgJzEnKTtcbiAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHNlYXJjaEJhciwgJ2JhY2tncm91bmQtY29sb3InLCAnd2hpdGUnKTtcbiAgfVxuXG4gIHByaXZhdGUgc2VsZWN0TmF0aXZlU2VsZWN0QWxsQ2hlY2tib3goKTogdm9pZCB7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5uYXRpdmVTZWxlY3RBbGxDaGVja2JveCwgJ2NoZWNrZWQnLCAndHJ1ZScpO1xuICB9XG5cbiAgcHJpdmF0ZSBkZXNlbGVjdE5hdGl2ZVNlbGVjdEFsbENoZWNrYm94KCk6IHZvaWQge1xuICAgIHRoaXMucmVuZGVyZXIucmVtb3ZlQXR0cmlidXRlKHRoaXMubmF0aXZlU2VsZWN0QWxsQ2hlY2tib3gsICdjaGVja2VkJyk7XG4gIH1cblxuICBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICB0aGlzLmNsaWNrTGlzdGVuZXJTZWxlY3RBbGwoKTtcbiAgfVxufVxuIiwiPGRpdiBjbGFzcz1cImZsZXgtY29udGFpbmVyXCI+XG4gIDxpbnB1dFxuICAgICNpbnB1dFxuICAgIGlkPVwiaW5wdXRcIlxuICAgIFtwbGFjZWhvbGRlcl09XCJzZWFyY2hQbGFjZUhvbGRlclwiXG4gICAgYXV0b2NvbXBsZXRlPVwib2ZmXCJcbiAgICAoaW5wdXQpPVwiZmlsdGVyTGlzdCgkZXZlbnQpXCJcbiAgICAoa2V5ZG93bik9XCJzdG9wQ2hhclByb3BhZ2F0aW9uKCRldmVudClcIj5cbiAgICA8bWF0LXNwaW5uZXIgKm5nSWY9XCJpc0xvYWRpbmdcIiBbZGlhbWV0ZXJdPVwiMjVcIj48L21hdC1zcGlubmVyPlxuPC9kaXY+XG48bWF0LWRpdmlkZXI+PC9tYXQtZGl2aWRlcj5cbiJdfQ==